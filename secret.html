<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Secret Santa Draw (8 people)</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
    .wrap { max-width: 900px; margin: 0 auto; padding: 20px; }
    h1 { margin: 0 0 8px; font-size: 22px; }
    p { margin: 8px 0 14px; opacity: 0.85; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 14px; }
    @media (min-width: 840px) { .grid { grid-template-columns: 1fr 1fr; } }
    .card { border: 1px solid rgba(127,127,127,0.25); border-radius: 14px; padding: 14px; }
    label { display: block; font-size: 12px; opacity: 0.8; margin-bottom: 6px; }
    input[type="text"] { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(127,127,127,0.35); }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(127,127,127,0.35); cursor: pointer; }
    button.primary { font-weight: 700; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .muted { opacity: 0.75; font-size: 12px; }
    .danger { color: #b00020; }
    table { width: 100%; border-collapse: collapse; }
    th, td { text-align: left; padding: 10px; border-bottom: 1px solid rgba(127,127,127,0.2); vertical-align: top; }
    th { font-size: 12px; opacity: 0.8; }
    .pill { display: inline-block; padding: 2px 8px; border: 1px solid rgba(127,127,127,0.35); border-radius: 999px; font-size: 12px; opacity: 0.9; }
    .revealBox { display: grid; grid-template-columns: 1fr auto; gap: 8px; }
    .hidden { display: none; }
    .ok { color: #0a7a2f; }
    .copy { margin-left: auto; }
    textarea { width: 100%; min-height: 160px; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(127,127,127,0.35); }
    .hr { height: 1px; background: rgba(127,127,127,0.2); margin: 12px 0; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Secret Santa Draw (8 people)</h1>
    <p>
      Runs entirely in your browser (no server). Enter 8 names, click <b>Draw</b>.
      It generates (1) who each person gives to and (2) a 4-digit PIN for each person.
      Share each person’s PIN privately. They can reveal only their own match by entering the PIN.
    </p>

    <div class="grid">
      <div class="card">
        <h2 style="margin:0 0 10px; font-size:16px;">Names</h2>
        <div id="names"></div>

        <div class="row" style="margin-top:12px;">
          <button class="primary" id="drawBtn">Draw</button>
          <button id="resetBtn">Reset</button>
          <span class="muted" id="status"></span>
        </div>

        <div class="hr"></div>

        <div class="row">
          <label style="margin:0;">Options</label>
        </div>
        <div class="row">
          <label class="muted" style="display:flex; gap:8px; align-items:center; margin:0;">
            <input type="checkbox" id="allowCouples" />
            Avoid specific pairs (optional, add below)
          </label>
        </div>
        <div id="couplesBox" class="hidden" style="margin-top:8px;">
          <p class="muted" style="margin:0 0 8px;">
            Add “blocked pairs” (e.g., spouses). Format: <span class="pill">Alice,Bob</span> one per line. Blocks both directions.
          </p>
          <textarea id="blockedPairs" placeholder="Alice,Bob&#10;Carol,Dan"></textarea>
        </div>
      </div>

      <div class="card">
        <h2 style="margin:0 0 10px; font-size:16px;">Reveal your match</h2>
        <p class="muted">
          After drawing, select your name, enter your PIN, and reveal who you give to.
          (This is “good enough” for casual use; anyone with developer tools could still inspect page state.)
        </p>

        <div id="revealArea" class="muted">Draw first.</div>

        <div id="exportArea" class="hidden" style="margin-top:12px;">
          <div class="hr"></div>
          <div class="row">
            <h3 style="margin:0; font-size:14px;">Organizer export</h3>
            <button class="copy" id="copyExportBtn">Copy PIN messages</button>
          </div>
          <p class="muted" style="margin:6px 0 8px;">
            This generates text you can paste into DMs (each person gets only their own PIN).
          </p>
          <textarea id="exportText" readonly></textarea>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const N = 8;

  const elNames = document.getElementById("names");
  const drawBtn = document.getElementById("drawBtn");
  const resetBtn = document.getElementById("resetBtn");
  const statusEl = document.getElementById("status");

  const allowCouples = document.getElementById("allowCouples");
  const couplesBox = document.getElementById("couplesBox");
  const blockedPairsTA = document.getElementById("blockedPairs");

  const revealArea = document.getElementById("revealArea");
  const exportArea = document.getElementById("exportArea");
  const exportText = document.getElementById("exportText");
  const copyExportBtn = document.getElementById("copyExportBtn");

  let state = null; // { names[], pinsByName, giveToByName, revealedByName }

  function makeNameInputs() {
    elNames.innerHTML = "";
    for (let i = 0; i < N; i++) {
      const wrap = document.createElement("div");
      wrap.style.marginBottom = "10px";
      const label = document.createElement("label");
      label.textContent = `Person ${i+1}`;
      const input = document.createElement("input");
      input.type = "text";
      input.placeholder = "Name";
      input.autocomplete = "off";
      input.spellcheck = false;
      input.id = `name_${i}`;
      wrap.appendChild(label);
      wrap.appendChild(input);
      elNames.appendChild(wrap);
    }
  }

  function setStatus(msg, isError=false) {
    statusEl.textContent = msg;
    statusEl.className = isError ? "muted danger" : "muted";
  }

  function cryptoRandInt(maxExclusive) {
    // unbiased-ish using rejection
    if (maxExclusive <= 0) throw new Error("maxExclusive must be > 0");
    const uint32Max = 0xFFFFFFFF;
    const limit = uint32Max - (uint32Max % maxExclusive);
    const buf = new Uint32Array(1);
    while (true) {
      crypto.getRandomValues(buf);
      const x = buf[0];
      if (x < limit) return x % maxExclusive;
    }
  }

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = cryptoRandInt(i + 1);
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function parseBlockedPairs(namesSet) {
    const blocked = new Set();
    const lines = blockedPairsTA.value.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    for (const line of lines) {
      const parts = line.split(",").map(s => s.trim()).filter(Boolean);
      if (parts.length !== 2) continue;
      const [a, b] = parts;
      // only enforce if both are in the current names
      if (!namesSet.has(a) || !namesSet.has(b)) continue;
      blocked.add(`${a}=>${b}`);
      blocked.add(`${b}=>${a}`);
    }
    return blocked;
  }

  function isValidAssignment(names, recipients, blockedSet) {
    // recipients[i] is who names[i] gives to
    for (let i = 0; i < names.length; i++) {
      if (names[i] === recipients[i]) return false;
      if (blockedSet && blockedSet.has(`${names[i]}=>${recipients[i]}`)) return false;
    }
    // also ensure it's a permutation of same set
    const setA = new Set(names);
    const setB = new Set(recipients);
    if (setA.size !== names.length || setB.size !== names.length) return false;
    for (const n of setA) if (!setB.has(n)) return false;
    return true;
  }

  function generateDerangement(names, blockedSet) {
    // try shuffle until valid (N=8, so this is fast)
    const maxAttempts = 2000;
    const recipients = names.slice();
    for (let a = 0; a < maxAttempts; a++) {
      shuffle(recipients);
      if (isValidAssignment(names, recipients, blockedSet)) return recipients.slice();
    }
    return null;
  }

  function genPin() {
    // 4-digit pin, allow leading zeros
    const x = cryptoRandInt(10000);
    return String(x).padStart(4, "0");
  }

  function renderRevealUI() {
    if (!state) {
      revealArea.textContent = "Draw first.";
      exportArea.classList.add("hidden");
      return;
    }

    revealArea.innerHTML = "";

    const row = document.createElement("div");
    row.className = "row";

    const selectLabel = document.createElement("label");
    selectLabel.textContent = "Your name";
    const select = document.createElement("select");
    select.style.padding = "10px 12px";
    select.style.borderRadius = "10px";
    select.style.border = "1px solid rgba(127,127,127,0.35)";
    select.id = "whoSelect";
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "Select…";
    select.appendChild(opt0);
    for (const n of state.names) {
      const opt = document.createElement("option");
      opt.value = n;
      opt.textContent = n;
      select.appendChild(opt);
    }

    const pinLabel = document.createElement("label");
    pinLabel.textContent = "PIN";
    const pinInput = document.createElement("input");
    pinInput.type = "text";
    pinInput.inputMode = "numeric";
    pinInput.placeholder = "4 digits";
    pinInput.maxLength = 4;
    pinInput.style.width = "140px";

    const revealBtn = document.createElement("button");
    revealBtn.className = "primary";
    revealBtn.textContent = "Reveal";

    const msg = document.createElement("div");
    msg.className = "muted";
    msg.style.marginTop = "10px";

    const result = document.createElement("div");
    result.style.marginTop = "10px";

    row.appendChild(selectLabel);
    row.appendChild(select);
    row.appendChild(pinLabel);
    row.appendChild(pinInput);
    row.appendChild(revealBtn);

    revealArea.appendChild(row);
    revealArea.appendChild(msg);
    revealArea.appendChild(result);

    function setMsg(t, ok=false) {
      msg.textContent = t;
      msg.className = ok ? "muted ok" : "muted danger";
    }

    revealBtn.addEventListener("click", () => {
      result.textContent = "";
      const who = select.value.trim();
      const pin = pinInput.value.trim();
      if (!who) return setMsg("Select your name.", false);
      if (!/^\d{4}$/.test(pin)) return setMsg("Enter your 4-digit PIN.", false);
      if (state.revealedByName[who]) return setMsg("Already revealed for this name on this device.", false);
      if (state.pinsByName[who] !== pin) return setMsg("Incorrect PIN.", false);

      state.revealedByName[who] = true;
      setMsg("Revealed.", true);
      const giveTo = state.giveToByName[who];
      result.innerHTML = `<div class="card" style="padding:12px;border-radius:12px;">
        <div class="muted">You give to:</div>
        <div style="font-size:18px;font-weight:800;margin-top:6px;">${escapeHtml(giveTo)}</div>
      </div>`;
    });

    exportArea.classList.remove("hidden");
    exportText.value = state.names.map(n => {
      return `Hi ${n}! Your Secret Santa PIN is ${state.pinsByName[n]}. Go to the link and enter your name + PIN to reveal who you give to.`;
    }).join("\n\n");

    // best-effort persistence for revealed state only (optional)
    try {
      localStorage.setItem("ss_state_revealed", JSON.stringify(state.revealedByName));
    } catch {}
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, (c) => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[c]));
  }

  allowCouples.addEventListener("change", () => {
    couplesBox.classList.toggle("hidden", !allowCouples.checked);
  });

  drawBtn.addEventListener("click", () => {
    setStatus("");
    const names = [];
    for (let i = 0; i < N; i++) {
      const v = (document.getElementById(`name_${i}`).value || "").trim();
      names.push(v);
    }

    if (names.some(n => !n)) return setStatus("Fill in all 8 names.", true);

    const set = new Set(names);
    if (set.size !== names.length) return setStatus("Names must be unique.", true);

    const blockedSet = allowCouples.checked ? parseBlockedPairs(set) : new Set();

    const recipients = generateDerangement(names, blockedSet);
    if (!recipients) return setStatus("Could not find a valid draw (blocked pairs may be too restrictive).", true);

    const pinsByName = {};
    for (const n of names) pinsByName[n] = genPin();

    const giveToByName = {};
    for (let i = 0; i < names.length; i++) giveToByName[names[i]] = recipients[i];

    let revealedByName = {};
    for (const n of names) revealedByName[n] = false;

    // restore revealed state if exists (optional)
    try {
      const prev = JSON.parse(localStorage.getItem("ss_state_revealed") || "null");
      if (prev && typeof prev === "object") {
        for (const n of names) if (typeof prev[n] === "boolean") revealedByName[n] = prev[n];
      }
    } catch {}

    state = { names, pinsByName, giveToByName, revealedByName };
    setStatus("Draw complete. Share each person’s PIN privately.");
    renderRevealUI();
  });

  resetBtn.addEventListener("click", () => {
    state = null;
    setStatus("");
    for (let i = 0; i < N; i++) document.getElementById(`name_${i}`).value = "";
    try { localStorage.removeItem("ss_state_revealed"); } catch {}
    renderRevealUI();
  });

  copyExportBtn.addEventListener("click", async () => {
    try {
      await navigator.clipboard.writeText(exportText.value);
      setStatus("Copied PIN messages to clipboard.");
    } catch {
      setStatus("Could not copy automatically. Select and copy manually.", true);
    }
  });

  makeNameInputs();
  renderRevealUI();
})();
</script>
</body>
</html>

